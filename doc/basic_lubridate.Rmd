---
title: "Dates and times"
output: html_notebook
---

```{r}
library(tidyverse)
library(lubridate)
library(here)
```

# Functions for system date and time

```{r}
t <- today()
t
class(t)

n <- now()
n
class(n)
```

# Create date/time from other objects

Three ways:

- From a string
- From individual date-time components
- From an existing date/time object

## From a string

```{r}
ymd("2020-01-28")
dmy("28jan2020")
mdy("January 28th, 2020")
```

You can also convert dates from unquoted numbers.

```{r}
ymd(20200128)
```

Converting date and time. Note the default timezone.

```{r}
ymd_hms("2010-01-28 23:59:59")
dmy_hms("28jan2020 23:59:59")
dmy_hms("28jan2020 23-59-59")
dmy_hm("28jan2020 23:20")
dmy_h("28jan2020 23")
```

## From individual components

```{r}
make_datetime(
  year = 2020,
  month = 1,
  day = 28,
  hour = 14,
  min = 40,
  sec = 30
)
```

Exercise 1: A dataframe `dat` is constructed, including components of date/time. Use these components to create a new date/time variable

```{r}
dat <- tibble(
  year = 2020,
  month = round(runif(20, min = 1, max = 12)),
  day = round(runif(20, min = 1, max = 28)),
  hour = round(runif(20, min = 1, max = 24)),
  minute = round(runif(20, min = 1, max = 59)),
  second = round(runif(20, min = 1, max = 59))
)
```

```{r}
dat1 <- dat %>% 
  mutate(dt = make_datetime(year, month, day, hour, minute, second)) %>% 
  select(dt)
```

# Extracting components

You can extract each component of a date/time object.

```{r}
a <- "2020-05-04 02:55:54"
a_dt <- ymd_hms(a)

year(a_dt)
day(a_dt)
hour(a_dt)
```

You can also extract the day of the week, month, or year for a given date/time.

```{r}
mday(a_dt) # day of the month
yday(a_dt) # day of the year
wday(a_dt) # day of the week
```

If you want to know which quarter or semester (half a year) is in, you can do that too.

```{r}
quarter(a_dt)
quarter(a_dt, with_year = TRUE)

semester(a_dt)
semester(a_dt, with_year = TRUE)
```


Exercise 2: Extract each component of the datetime variable `dt` from `dat1` dataframe, including day of the month, day of the year, and day of the week. Display month and day of the week in words instead of numbers.

```{r}
dat2 <- dat1 %>% 
  mutate(year = year(dt),
         month = month(dt, label = TRUE),
         day = day(dt),
         hour = hour(dt),
         minute = minute(dt),
         second = second(dt),
         day_of_the_month = mday(dt),
         day_of_the_year = yday(dt),
         day_of_the_week = wday(dt, label = TRUE))
```

What is the frequency distribution of the quarters of these dates?

```{r}
dat1 %>% 
  mutate(q = quarter(dt, with_year = TRUE)) %>% 
  count(q)
```

# Time spans

Three important classes that represent time spans:

- Duration: an exact number of seconds (for a datetime)
- Periods: human units like weeks and months
- Intervals: a starting and ending point

## Duration

If John Snow is alive today, how old would he be?

```{r}
js_age <- today() - ymd(18130315)
js_age
class(js_age)
```


```{r}
as.difftime(seq(from = 10, to = 50, by = 10), units = "secs")
as.difftime(seq(from = 10, to = 50, by = 10), units = "hours")
as.difftime(seq(from = 10, to = 50, by = 10), units = "weeks")
```

`{lubridate}` always represents a duration in seconds.

```{r}
as.duration(js_age)
```

There are convenient functions to construct durations but it's always represented in seconds.

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

You can add and multiply durations:

```{r}
2 * dyears(2)
dyears(1) + dweeks(4) + ddays(7)
```

You can add and subtract durations to and from days:

```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

However, because durations represent an exact number of seconds, sometimes you might get an unexpected result:

```{r}
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")

one_pm
one_pm + ddays(1)
```

## Periods

```{r}
one_pm
one_pm + days(1)
```

Constructor functions for periods:

```{r}
seconds(15)
minutes(10)
hours(c(12, 24))
days(7)
months(1:6)
weeks(3)
years(1)
```

You can add and multiple periods.

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

You can also add periods to dates. Compared to durations, periods are more likely to do what you expect:

```{r}
# A leap year
ymd("2016-01-01") + dyears(1)
ymd("2016-01-01") + years(1)

# Daylight Savings Time
one_pm
one_pm + ddays(1)
one_pm + days(1)
```

Here is an example of differences in the results of adding durations and periods to a date/time because of leap year.

```{r}
dat3 <- dat1
dat3$r <- sample(-20:20, nrow(dat3), replace = TRUE)

dat3 <- dat3 %>% 
  mutate(d = dyears(r),
         p = years(r),
         dt_duration = dt + d,
         dt_period = dt + p,
         diff = as.duration(dt_duration - dt_period))

dat3
```

## Intervals



```{r}
dyears(1)/ddays(1)
years(1)/days(1)
```



# Time zones





```{r}
fb <- read_csv(here("data", "fb_new.csv"))
tw <- read_csv(here("data", "tw_new.csv"))
```

Who are the top 10 influencers who posted the highest number of tweets?

```{r}
top_10 <- tweet %>% 
  count(influencer, sort = TRUE) %>% 
  slice(1:10) %>% 
  pull(influencer)
```

Plot their total number of tweets against average AVE value using a scatter plot.

```{r}
tweet %>% 
  filter(influencer %in% top_10) %>% 
  group_by(influencer) %>% 
  summarise(ave = mean(ave, na.rm = TRUE),
            num_tweets = n()) %>% 
  ggplot(aes(x = num_tweets, y = ave)) +
  geom_point() +
  geom_text(aes(label = influencer), hjust = 1, vjust = -0.5, size = 3, check_overlap = TRUE) +
  labs(title = "AVE and number of tweets of influencers", x = "Number of tweets", y = "Mean value of AVE") +
  scale_x_continuous(limits = c(0, 1500), breaks = seq(0, 1500, 300)) +
  theme_classic()
```

Nature of sentiments of the top 10 influencer's tweets classified by algorithm.

```{r}
tweet %>% 
  filter(influencer %in% top_10) %>% 
  mutate(influencer = factor(influencer),
         sentiment = factor(sentiment, levels = c("Positive", "Negative", "Neutral", "Not Rated"))) %>% 
  ggplot(aes(x = fct_infreq(influencer), fill = fct_rev(sentiment))) +
  geom_bar(position = "fill") +
  scale_fill_viridis(discrete = TRUE, option = "D", alpha = 0.8) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(x = "Influencer", y = "", fill = "Sentiment of tweets") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.3),
        axis.ticks = element_blank())
```


```{r}
tweet %>% 
  group_by(language) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n)) %>% 
  slice(1:10) %>% 
  mutate(pos = factor(language)) %>% 
  ggplot(aes(x = fct_reorder(pos, n), y = n)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_y_continuous(limits  = c(0, 80000)) +
  labs(x = "Language", y = "Number of tweets")
```
  
```{r}
fb %>% 
  group_by(language) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n)) %>% 
  slice(1:10) %>% 
  mutate(pos = factor(language)) %>% 
  ggplot(aes(x = fct_reorder(pos, n), y = n)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_y_continuous(limits  = c(0, 80000)) +
  labs(x = "Language of posts", y = "Number of facebook posts")
```

```{r}
tweet1 <- tweet %>% 
  mutate(datetime = make_datetime(year, month, day, time %/% 100, time %% 100))

fb1 <- fb %>% 
  mutate(datetime = parse_date_time(date, "ymdHMS"))
```

```{r}
social_media <- bind_rows(
  Twitter = tweet1 %>% select(datetime),
  Facebook = fb1 %>% select(datetime),
  .id = "source"
)

social_media %>% 
  ggplot(aes(x = datetime, col = source)) +
  geom_freqpoly(binwidth = 60*60*24)

tw1date <- range(tw1$datetime)
(tw1date[1] %--% tw1date[2]) %/% days(1)

test <- social_media %>% 
  mutate(dt = date(datetime)) %>% 
  count(source, dt) %>% 
  pivot_wider(names_from = source,
              values_from = n)

ggplot(test, aes(x = fb, y = tw)) +
  geom_point()
```


