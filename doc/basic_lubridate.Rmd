---
title: "Dates and times"
output: html_notebook
---

```{r}
library(tidyverse)
library(lubridate)
library(here)
```

# Functions for system date and time

```{r}
t <- today()
t
class(t)

n <- now()
n
class(n)
```

# Create date/time from other objects

Three ways:

- From a string
- From individual date-time components
- From an existing date/time object

## From a string

```{r}
ymd("2020-01-28")
dmy("28jan2020")
mdy("January 28th, 2020")
```

You can also convert dates from unquoted numbers.

```{r}
ymd(20200128)
```

Converting date and time. Note the default timezone.

```{r}
ymd_hms("2010-01-28 23:59:59")
dmy_hms("28jan2020 23:59:59")
dmy_hms("28jan2020 23-59-59")
dmy_hm("28jan2020 23:20")
dmy_h("28jan2020 23")
```

## From individual components

```{r}
make_datetime(
  year = 2020,
  month = 1,
  day = 28,
  hour = 14,
  min = 40,
  sec = 30
)
```

Exercise 1: A dataframe `dat` is constructed, including components of date/time. Use these components to create a new date/time variable

```{r}
dat <- tibble(
  year = 2020,
  month = round(runif(20, min = 1, max = 12)),
  day = round(runif(20, min = 1, max = 28)),
  hour = round(runif(20, min = 1, max = 24)),
  minute = round(runif(20, min = 1, max = 59)),
  second = round(runif(20, min = 1, max = 59))
)
```

```{r}
dat1 <- dat %>% 
  mutate(dt = make_datetime(year, month, day, hour, minute, second)) %>% 
  select(dt)
```

# Extracting components

You can extract each component of a date/time object.

```{r}
a <- "2020-05-04 02:55:54"
a_dt <- ymd_hms(a)

year(a_dt)
day(a_dt)
hour(a_dt)
```

You can also extract the day of the week, month, or year for a given date/time.

```{r}
mday(a_dt) # day of the month
yday(a_dt) # day of the year
wday(a_dt) # day of the week
```

If you want to know which quarter or semester (half a year) is in, you can do that too.

```{r}
quarter(a_dt)
quarter(a_dt, with_year = TRUE)

semester(a_dt)
semester(a_dt, with_year = TRUE)
```

Exercise 2: Extract each component of the datetime variable `dt` from `dat1` dataframe, including day of the month, day of the year, and day of the week. Display month and day of the week in words instead of numbers.

```{r}
dat2 <- dat1 %>% 
  mutate(year = year(dt),
         month = month(dt, label = TRUE),
         day = day(dt),
         hour = hour(dt),
         minute = minute(dt),
         second = second(dt),
         day_of_the_month = mday(dt),
         day_of_the_year = yday(dt),
         day_of_the_week = wday(dt, label = TRUE))
```

What is the frequency distribution of the quarters of these dates?

```{r}
dat1 %>% 
  mutate(q = quarter(dt, with_year = TRUE)) %>% 
  count(q)
```

# Time spans

Three important classes that represent time spans:

- Duration: an exact number of seconds
- Period: allows calculation by calendar week, month, and year - this way of calculation is probably more familiar to us.
- Intervals: measured in seconds but with a starting date

Let's take a look at functions that work with these time span classes.

## Duration

If John Snow is alive today, how old would he be?

```{r}
js_age <- today() - ymd(18130315)
js_age
class(js_age)
```

Duration is the difference between two dates or date/time objects. In base R, substraction of the two dates or date/time objects creates a `difftime` object. Its unit can be seconds, minutes, hours, days, and weeks (read the help file `?difftime`). It can be confusing to work with.

```{r}
as.difftime(seq(from = 10, to = 50, by = 10), units = "secs")
as.difftime(seq(from = 10, to = 50, by = 10), units = "hours")
as.difftime(seq(from = 10, to = 50, by = 10), units = "weeks")
```

In `{lubridate}`, a duration is always represented in seconds.

```{r}
as.duration(js_age)
```

We can construct duration based on numbers in second, minute, hour, day, week and year using convenient functions from `lubridate`. The output of these functions is the equivalent number of seconds.

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

Note that there is no `dmonths()`. Why is that?

You can add and multiply durations:

```{r}
2 * dyears(2)
dyears(1) + dweeks(4) + ddays(7)
```

You can add and subtract durations to and from days:

```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

## Periods

Calculation using durations may get you an unexpected result. The number of seconds in a year or a month can vary because of different days in a month, leap year, and daylight savings time.

```{r}
# A leap year
ymd("2016-01-01") + dyears(1)

# Daylight Savings Time
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")
one_pm + ddays(1)
```

This is where period comes in. It allows adding one year to January 1, 2020 and become January 1, 2021, instead of 31 December 2020 because of the leap year. Compared to durations, periods are more likely to do what you expect:

```{r}
# A leap year
ymd("2016-01-01") + dyears(1)
ymd("2016-01-01") + years(1)

# Daylight Savings Time
one_pm
one_pm + ddays(1)
one_pm + days(1)
```

We can construct periods from numbers:

```{r}
seconds(15)
minutes(10)
hours(c(12, 24))
days(7)
months(1:6)
weeks(3)
years(1)
```

You can also add and multiply periods.

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

Exercise 3: A new column year is created in `dat1` using random numbers. Convert this column into both duration and period and add them to `dt` column. Check whether and to what extent the results are different and why?

```{r}
dat3 <- dat1
dat3$year <- sample(-20:20, nrow(dat3), replace = TRUE)

dat3 <- dat3 %>% 
  mutate(d = dyears(year),
         p = years(year),
         dt_duration = dt + d,
         dt_period = dt + p,
         diff = as.duration(dt_duration - dt_period))

dat3
```

## Intervals

`dyears(1) / ddays(1)` returns 365 because durations are always represented by a number of seconds, and a duration of a year is defined as 365 days worth of seconds.

Let's do the same calculation using periods.

```{r}
years(1) / days(1)
```

A period represents calendar time and it returns 365.25 with a message stating that it's an imprecise estimate. Why is that? That is because it would return 366 if it was a leap year. Since we do not know when that period started, we cannot know the period accurately; we should use an interval instead (if we have the start dates).

`interval()` function creates interval objects. `%--%` is the shorthand for the function. An interval object prints the start and end dates rather than seconds.

```{r}
my_int1 <- ymd_hms("2016-03-12 13:00:00") %--% ymd_hms("2017-04-12 13:00:00")
my_int2 <- ymd_hms("2016-08-01 13:00:00") %--% ymd_hms("2017-08-12 13:00:00")
my_int1
my_int2
```

You can extract start and end dates.

```{r}
int_start(my_int1)
int_end(my_int1)
```

You can change the start or end dates in place.

```{r}
int_start(my_int1) <- ymd_hms("2016-01-01 13:00:00")
int_end(my_int1) <- ymd_hms("2017-01-01 13:00:00")
my_int1
```

You can test whether a date falls within an interval.

```{r}
ymd_hms("2016-05-01 13:00:00") %within% my_int1
ymd_hms("1999-05-01 13:00:00") %within% my_int1
```

You can also test whether two intervals overlaps.

```{r}
int_overlaps(my_int1, my_int2)
```

# Time zones

System time zone

Complete list of timezone names

Default time zone: UTC (Coordinated Universal Time), does not have DST


Change time zone in two ways:

1. Keep the instant in time the same, and change how it's displayed.

```{r}
with_tz()
```


2. Change the underlying instant in time. Use this when the instant is labelled with an incorrect timezone.

```{r}
force_tz()
```


```{r}
fb <- read_csv(here("data", "fb_new.csv"))
tw <- read_csv(here("data", "tw_new.csv"))
```

Who are the top 10 influencers who posted the highest number of tweets?

```{r}
top_10 <- tweet %>% 
  count(influencer, sort = TRUE) %>% 
  slice(1:10) %>% 
  pull(influencer)
```

Plot their total number of tweets against average AVE value using a scatter plot.

```{r}
tweet %>% 
  filter(influencer %in% top_10) %>% 
  group_by(influencer) %>% 
  summarise(ave = mean(ave, na.rm = TRUE),
            num_tweets = n()) %>% 
  ggplot(aes(x = num_tweets, y = ave)) +
  geom_point() +
  geom_text(aes(label = influencer), hjust = 1, vjust = -0.5, size = 3, check_overlap = TRUE) +
  labs(title = "AVE and number of tweets of influencers", x = "Number of tweets", y = "Mean value of AVE") +
  scale_x_continuous(limits = c(0, 1500), breaks = seq(0, 1500, 300)) +
  theme_classic()
```

Nature of sentiments of the top 10 influencer's tweets classified by algorithm.

```{r}
tweet %>% 
  filter(influencer %in% top_10) %>% 
  mutate(influencer = factor(influencer),
         sentiment = factor(sentiment, levels = c("Positive", "Negative", "Neutral", "Not Rated"))) %>% 
  ggplot(aes(x = fct_infreq(influencer), fill = fct_rev(sentiment))) +
  geom_bar(position = "fill") +
  scale_fill_viridis(discrete = TRUE, option = "D", alpha = 0.8) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(x = "Influencer", y = "", fill = "Sentiment of tweets") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.3),
        axis.ticks = element_blank())
```


```{r}
tweet %>% 
  group_by(language) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n)) %>% 
  slice(1:10) %>% 
  mutate(pos = factor(language)) %>% 
  ggplot(aes(x = fct_reorder(pos, n), y = n)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_y_continuous(limits  = c(0, 80000)) +
  labs(x = "Language", y = "Number of tweets")
```
  
```{r}
fb %>% 
  group_by(language) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n)) %>% 
  slice(1:10) %>% 
  mutate(pos = factor(language)) %>% 
  ggplot(aes(x = fct_reorder(pos, n), y = n)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_y_continuous(limits  = c(0, 80000)) +
  labs(x = "Language of posts", y = "Number of facebook posts")
```

```{r}
tweet1 <- tweet %>% 
  mutate(datetime = make_datetime(year, month, day, time %/% 100, time %% 100))

fb1 <- fb %>% 
  mutate(datetime = parse_date_time(date, "ymdHMS"))
```

```{r}
social_media <- bind_rows(
  Twitter = tweet1 %>% select(datetime),
  Facebook = fb1 %>% select(datetime),
  .id = "source"
)

social_media %>% 
  ggplot(aes(x = datetime, col = source)) +
  geom_freqpoly(binwidth = 60*60*24)

tw1date <- range(tw1$datetime)
(tw1date[1] %--% tw1date[2]) %/% days(1)

test <- social_media %>% 
  mutate(dt = date(datetime)) %>% 
  count(source, dt) %>% 
  pivot_wider(names_from = source,
              values_from = n)

ggplot(test, aes(x = fb, y = tw)) +
  geom_point()
```


